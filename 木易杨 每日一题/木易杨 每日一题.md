## 每日一题

> 每天一道大厂前端面试题，一年后再回头，会感谢曾经努力的自己！
>
> 待更新状态
>
> 今天 2019/9/28  ~ 💪



### [第 1 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md#%E7%AC%AC-1-%E9%A2%98%E5%86%99-react--vue-%E9%A1%B9%E7%9B%AE%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8%E5%88%97%E8%A1%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%86%99-key%E5%85%B6%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88) （2019/9/19）

**题目**：写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？

**公司**：滴滴、饿了么

**需了解** ：vue和react都是采用diff算法来对比新旧虚拟节点，从而更新节点。在vue的diff函数中。可以先了解一下diff算法。
在交叉对比的时候，当新节点跟旧节点`头尾交叉对比`没有结果的时候，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点（这里对应的是一个key => index 的map映射）。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用一种遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。

**答案**： 

> key是给每一个vnode的唯一id,可以`依靠key`,更`准确`, 更`快`的拿到oldVnode中对应的vnode节点。
>
> key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度。

1、更准确

因为带key就不是`就地复用`了，在sameNode函数 `a.key === b.key`对比中可以避免就地复用的情况。所以会更加准确。

2、更快

利用key的唯一性生成map对象来获取对应节点，比遍历方式更快。(这个观点，就是我最初的那个观点。从这个角度看，map会比遍历更快。)



### [第 2 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/4)（2019/9/20）

**题目**：`['1', '2', '3'].map(parseInt)` what & why ?

**答案** ：第一眼看到这个题目的时候，脑海跳出的答案是 [1, 2, 3]，但是 **真正的答案是[1, NaN, NaN]**。

```js
    console.log(parseInt('12'));//12
    console.log(parseInt('08'));//8
    console.log(parseInt('0x16')); //22
    console.log(parseInt('-12')); //-12
    console.log(parseInt('   -12'));//-12
    console.log(parseInt('   -  12'));///NAN
    console.log(parseInt('124ref')); //124
    console.log(parseInt('ref'));   //NAN
```

以上几乎就是`parseInt`函数一个形式参数时的所有情况

radix形参没指定的时候是**10**，其次他是具有有效范围滴：[2, 36]和特殊值0
下面是英语渣渣的我翻译后，简化的`parseInt`执行步骤：（ECMAScript原解析->[传送门](http://www.ecma-international.org/ecma-262/6.0/#sec-parseint-string-radix)）

1. 将第一个形参转换为字符串
2. 识别string转换是否有**code unit**，如果有 -> `-`标记为负数，`0x`或`0X`则把radix赋值为**16**
3. radix形参（int类型）是否存在，存在则重新赋值（会对实参进行Int32转化，无法转换成int类型则不会重新赋值radix）
4. radix为0，则设置radix为默认值10
5. 如果radix为1，或者大于等于37，parseInt直接返回**NaN**
6. 如果radix为[2, 36]时则代表，string参数分别是二进制，三进制（如果有得话~）...三十六进制类型
7. 然后对string进行的radix进制 -> 十进制转换

以上就是`parseInt`转换时的步骤，那么我们来开始解释`['1', '2', '3'].map(parseInt)`
**at first, 答案是[1, NaN, NaN]**

```js
(function (){
        var ret = ['1', '2', '3'].map((value, index)=>{
            console.log(value, index);
            return parseInt(value, index);
        });
        console.log(ret);
    })();
```

这是`['1', '2', '3'].map(parseInt)`内部执行的剖析，`value`和`index`相信大家都懂，不懂请自行[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/map),执行步骤为：
`value='1',index=0` -> `parseInt(value, index)`
`value='2',index=1` -> `parseInt(value, index)`
`value='3',index=2` -> `parseInt(value, index)`
抽离出来，其实就是

```js
parseInt('1', 0);
parseInt('2', 1);
parseInt('3', 2);
```

`parseInt('3', 2)`这是根据二进制对字符串`3`进行十进制转换对吧！！！
exm???有毛病?没毛病，老铁，就是......你家二进制有`3`?二进制不就是`0`和`1`啊

因此返回**NaN**。



### [第 3 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/5)（2019/9/21）

**题目**：什么是防抖和节流？有什么区别？如何实现？

**公司** ：挖财

**解析** ：

1、**防抖**

> 触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间

思路：

> 每次触发事件时都取消之前的延时调用方法

```js
    function debounce(fn,delay) {
        let timeout = null // 创建一个标记用来存放定时器的返回值
        return function () {
            clearTimeout(timeout) // 每当用户输入的时候把前一个 setTimeout clear 掉
            timeout = setTimeout(() => { // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
                fn.apply(this, arguments)
        }, delay)
        };
    }
    function sayHi() {
        console.log('防抖成功');
    }

    var inp = document.getElementById('inp')
    inp.addEventListener('input', debounce(sayHi,500)) // 防抖
```

提出问题：请问，为什么要 fn.apply(this, arguments);而不是这样 fn()

解答：加上 apply 确保 在 sayHi 函数里的 this 指向的是 input对象(不然就指向 window 了，不是我们想要的)。
这里的箭头函数依旧是指向 input 对象。

![mark](http://static.zxinc520.com/blog/20190921/g4jPyh09vVh7.gif)

防抖应用场景：

1. 搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。
2. 表单验证
3. 按钮提交事件。
4. 浏览器窗口缩放，resize事件等。



2、**节流**

> 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率

思路：

> 每次触发事件时都判断当前是否有等待执行的延时函数

```js
  function throttle(fn,delay) {
        let canRun = true; // 通过闭包保存一个标记
        return function () {
            if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return
            canRun = false; // 立即设置为false
            setTimeout(() => { // 将外部传入的函数的执行放在setTimeout中
                fn.apply(this, arguments);
            // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉
            canRun = true;
        }, 500);
        };
    }
    function sayHi(e) {
        console.log(e.target.innerWidth, e.target.innerHeight);
    }
    window.addEventListener('resize', throttle(sayHi,500));
```

![mark](http://static.zxinc520.com/blog/20190921/nJbaVeD1wpaz.gif)



### [第 4 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md#%E7%AC%AC-4-%E9%A2%98%E4%BB%8B%E7%BB%8D%E4%B8%8B-setmapweakset-%E5%92%8C-weakmap-%E7%9A%84%E5%8C%BA%E5%88%AB) (2019/9/22)

**题目** ：介绍下 Set、Map、WeakSet 和 WeakMap 的区别？

**解析：** [木易杨前端进阶](https://muyiy.cn/question/js/4.html) 

~~~txt
Set
    成员唯一、无序且不重复
    [value, value]，键值与键名是一致的（或者说只有键值，没有键名）
    可以遍历，方法有：add、delete、has
    
WeakSet
    成员都是对象
    成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏
    不能遍历，方法有add、delete、has
    
Map
    本质上是键值对的集合，类似集合
    可以遍历，方法很多可以跟各种数据格式转换
    
WeakMap
    只接受对象作为键名（null除外），不接受其他类型的值作为键名
    键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的
    不能遍历，方法有get、set、has、delete
 
 Set与WeakSet区别:
    1. WeakSet只能存放对象
    2. WeakSet不支持遍历, 没有size熟悉
    3. WeakSet存放的对象不会计入到对象的引用技术, 因此不会影响GC的回收
    4. WeakSet存在的对象如果在外界消失了, 那么在WeakSet里面也会不存在
    
 Map与WeakMap区别
 	1. WeakMap只能接受对象作为键名字(null除外)
	2. WeakMap键名指向对象不会计入对象的引用数
~~~



### [第 5 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/9) (2019/9/22)

**题目：** 介绍下深度优先遍历和广度优先遍历，如何实现？

解析： 我先学习一下啥是  深度优先 和 广度优先... 惭愧！！！



### [第 6 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/10) （2019/9/23）

**题目** ：请分别用深度优先思想和广度优先思想实现一个拷贝函数？

> 弄懂了 优先遍历和广度优先遍历 再来做





### [第 7 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/20) （2019/9/23）

**题目** ：ES5/ES6 的继承除了写法以外还有什么区别？

**解析** ： [更多](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/20)

1. `class` 声明会提升，但不会初始化赋值。`Foo` 进入暂时性死区，类似于 `let`、`const` 声明变量。
2. `class` 声明内部会启用严格模式。
3. `class` 的所有方法（包括静态方法和实例方法）都是不可枚举的。
4. `class` 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有`[[construct]]`，不能使用 `new` 来调用。
5. 必须使用 `new` 调用 `class`。
6. `class` 内部无法重写类名。



### [第 8 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/33)（2019/9/24）

**题目：** setTimeout、Promise、Async/Await 的区别 ？

**知识点** ：这里涉及到`Microtasks`、`Macrotasks`、event loop 以及 JS 的异步运行机制。[可参考](https://github.com/sisterAn/blog/issues/21) 

**解析** ： 

~~~txt
我觉得这题主要是考察这三者在事件循环中的区别，事件循环中分为宏任务队列和微任务队列。
其中 setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行；
promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；async函数表示函数里面可能会有异步方法，await后面跟一个表达式，async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。
~~~

**1、setTimeout**

~~~js
console.log('script start')	//1. 打印 script start
setTimeout(function(){
    console.log('settimeout')	// 4. 打印 settimeout
})	// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数
console.log('script end')	//3. 打印 script start
// 输出顺序：script start->script end->settimeout
~~~

**2、 Promise** 

Promise本身是**同步的立即执行函数**， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。

~~~js
console.log('script start')
let promise1 = new Promise(function (resolve) {
    console.log('promise1')
    resolve()
    console.log('promise1 end')
}).then(function () {
    console.log('promise2')
})
setTimeout(function(){
    console.log('settimeout')
})
console.log('script end')
// 输出顺序: script start->promise1->promise1 end->script end->promise2->settimeout
~~~

当JS主线程执行到Promise对象时，

- promise1.then() 的回调就是一个 task
- promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue
- promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中
- setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况

**3. async/await** 

~~~js
async function async1(){
   console.log('async1 start');
    await async2();
    console.log('async1 end')
}
async function async2(){
    console.log('async2')
}

console.log('script start');
async1();
console.log('script end')

// 输出顺序：script start->async1 start->async2->script end->async1 end
~~~

async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。

举个例子：

~~~js
async function func1() {
    return 1
}

console.log(func1())
~~~

![mark](http://static.zxinc520.com/blog/20190924/M0YN5oCKtEhr.png?imageslim)

很显然，func1的运行结果其实就是一个Promise对象。因此我们也可以使用then来处理后续逻辑。

~~~js
func1().then(res => {
    console.log(res);  // 30
}
~~~

await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。

> 更多可见 [setTimeout、Promise、Async/Await](https://github.com/sisterAn/blog/issues/21)



### [第 9 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/33)（2019/9/25）

**题目** ： Async/Await 如何通过同步的方式实现异步？

**公司** ：头条、微医   

**解析** ：  [Async/Await 如何通过同步的方式实现异步](Async/Await 如何通过同步的方式实现异步) 

首先，`async/await` 是 `Generator` 的语法糖

先来看一下二者的对比：

~~~JS
// Generator
run(function*() {
  const res1 = yield readFile(path.resolve(__dirname, '../data/a.json'), { encoding: 'utf8' });
  console.log(res1);
  const res2 = yield readFile(path.resolve(__dirname, '../data/b.json'), { encoding: 'utf8' });
  console.log(res2);
});

// async/await
const readFile = async ()=>{
  const res1 = await readFile(path.resolve(__dirname, '../data/a.json'), { encoding: 'utf8' });
  console.log(res1);
  const res2 = await readFile(path.resolve(__dirname, '../data/b.json'), { encoding: 'utf8' });
  console.log(res2);
  return 'done'；
}
const res = readFile();
~~~

可以看到，`async function` 代替了 `function*`，`await` 代替了 `yield`，同时也无需自己手写一个自动执行器 `run` 了

现在再来看看`async/await` 的特点：

- 当 `await` 后面跟的是 Promise 对象时，才会异步执行，其它类型的数据会同步执行
- 执行 `const res = readFile();` 返回的仍然是个 Promise 对象，上面代码中的 `return 'done';` 会直接被下面 `then` 函数接收到

~~~JS
res.then(data => {
  console.log(data); // done
});
~~~



### [第 10 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7)（2019/9/26）

**题目类型** ：异步笔试题

**公司** ：头条

> 请写出下面代码的运行结果
>

~~~js
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
    console.log('async2');
}
console.log('script start');
setTimeout(function() {
    console.log('setTimeout');
}, 0)
async1();
new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(function() {
    console.log('promise2');
});
console.log('script end');
/*  
    script start
    async1 start
    async2
    promise1
    script end
    async1 end
    promise2
    setTimeout
*/
~~~



### [第 11 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/8) （2019/9/26）

**公司** ：携程

> 已知如下数组：
>
> var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];
>
> 编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组

~~~js
Array.from(new Set(arr.flat(Infinity))).sort((a,b)=>{ return a-b}) //使用 flat
//或
Array.from(new Set(arr.toString().split(','))).sort((a,b)=>{return a-b}).map(Number) //利用 toString()
~~~



### [第 12 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/11) （2019/9/27）

**题目：** JS 异步解决方案的发展历程以及优缺点。

**公司** ：滴滴、挖财、微医、海康

**解析：** 

1. **回调函数（callback）** 

~~~js
setTimeout(() => {
    // callback 函数体
}, 1000)
~~~

**缺点**：回调地狱，不能用 try catch 捕获错误，不能 return 

回调地狱的根本问题在于：

- 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符
- 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（**控制反转**）
- 嵌套函数过多的多话，很难处理错误

**优点** ：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）

2. **Promise** 

Promise就是为了解决callback的问题而产生的。

Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装

**优点** ：解决了回调地狱的问题

~~~js
ajax('XXX1')
  .then(res => {
      // 操作逻辑
      return ajax('XXX2')
  }).then(res => {
      // 操作逻辑
      return ajax('XXX3')
  }).then(res => {
      // 操作逻辑
  })
~~~

**缺点** ：无法取消 Promise ，错误需要通过回调函数来捕获

3. **Generato** 

**特点** ：可以控制函数的执行，可以配合 co 函数库使用

~~~js
function *fetch() {
    yield ajax('XXX1', () => {})
    yield ajax('XXX2', () => {})
    yield ajax('XXX3', () => {})
}
let it = fetch()
let result1 = it.next()
let result2 = it.next()
let result3 = it.next()
~~~

4. **Async/await** 

async、await 是异步的终极解决方案

**优点**：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题

**缺点**：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。

~~~js
async function test() {
  // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式
  // 如果有依赖性的话，其实就是解决回调地狱的例子了
  await fetch('XXX1')
  await fetch('XXX2')
  await fetch('XXX3')
}
~~~

下面来看一个使用 `await` 的例子：

~~~js
let a = 0
let b = async () => {
  a = a + await 10
  console.log('2', a) // -> '2' 10
}
b()
a++
console.log('1', a) // -> '1' 1
~~~

对于以上代码你可能会有疑惑，让我来解释下原因

- 首先函数 `b` 先执行，在执行到 `await 10` 之前变量 `a` 还是 0，因为 `await` 内部实现了 `generator` ，**generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来**
- 因为 `await` 是异步操作，后来的表达式不返回 `Promise` 的话，就会包装成 `Promise.reslove(返回值)`，然后会去执行函数外的同步代码
- 同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 `a = 0 + 10`

上述解释中提到了 `await` 内部实现了 `generator`，其实 `await` 就是 `generator` 加上 `Promise`的语法糖，且内部实现了自动执行 `generator`。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。



### [第 13 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/19) （2019/9/28）

**题目** ：Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？

**公司** ：微医

~~~txt
看过 Event Loop 基础原理的就明白，Promise构造函数是同步执行，而 .then .catch .啥啥的是异步（还有process.nextTick等等，大家可以查），
而且放到了微队列中，async/await 中，await 前面的是同步，await 后面的是异步，写法上是这样，但是其实是 语法糖，最后还会转为 Promise.then的形式

.then()当然是同步执行，只不过是.then的cb被放入了微任务队列，产生了异步执行

promise是微观任务，setTimeout是宏观任务，先执行微观任务，在执行宏观任务；微观任务里，先执行同步再执行异步
~~~























