## 每日一题

> 每天一道大厂前端面试题，一年后再回头，会感谢曾经努力的自己！
>
> 待更新状态
>
> 今天 2019/9/23  ~ 💪



### [第 1 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md#%E7%AC%AC-1-%E9%A2%98%E5%86%99-react--vue-%E9%A1%B9%E7%9B%AE%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8%E5%88%97%E8%A1%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%86%99-key%E5%85%B6%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88) （2019/9/19）

**题目**：写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？

**公司**：滴滴、饿了么

**需了解** ：vue和react都是采用diff算法来对比新旧虚拟节点，从而更新节点。在vue的diff函数中。可以先了解一下diff算法。
在交叉对比的时候，当新节点跟旧节点`头尾交叉对比`没有结果的时候，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点（这里对应的是一个key => index 的map映射）。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用一种遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。

**答案**： 

> key是给每一个vnode的唯一id,可以`依靠key`,更`准确`, 更`快`的拿到oldVnode中对应的vnode节点。
>
> key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度。

1、更准确

因为带key就不是`就地复用`了，在sameNode函数 `a.key === b.key`对比中可以避免就地复用的情况。所以会更加准确。

2、更快

利用key的唯一性生成map对象来获取对应节点，比遍历方式更快。(这个观点，就是我最初的那个观点。从这个角度看，map会比遍历更快。)



### [第 2 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/4)（2019/9/20）

**题目**：`['1', '2', '3'].map(parseInt)` what & why ?

**答案** ：第一眼看到这个题目的时候，脑海跳出的答案是 [1, 2, 3]，但是 **真正的答案是[1, NaN, NaN]**。

```js
    console.log(parseInt('12'));//12
    console.log(parseInt('08'));//8
    console.log(parseInt('0x16')); //22
    console.log(parseInt('-12')); //-12
    console.log(parseInt('   -12'));//-12
    console.log(parseInt('   -  12'));///NAN
    console.log(parseInt('124ref')); //124
    console.log(parseInt('ref'));   //NAN
```

以上几乎就是`parseInt`函数一个形式参数时的所有情况

radix形参没指定的时候是**10**，其次他是具有有效范围滴：[2, 36]和特殊值0
下面是英语渣渣的我翻译后，简化的`parseInt`执行步骤：（ECMAScript原解析->[传送门](http://www.ecma-international.org/ecma-262/6.0/#sec-parseint-string-radix)）

1. 将第一个形参转换为字符串
2. 识别string转换是否有**code unit**，如果有 -> `-`标记为负数，`0x`或`0X`则把radix赋值为**16**
3. radix形参（int类型）是否存在，存在则重新赋值（会对实参进行Int32转化，无法转换成int类型则不会重新赋值radix）
4. radix为0，则设置radix为默认值10
5. 如果radix为1，或者大于等于37，parseInt直接返回**NaN**
6. 如果radix为[2, 36]时则代表，string参数分别是二进制，三进制（如果有得话~）...三十六进制类型
7. 然后对string进行的radix进制 -> 十进制转换

以上就是`parseInt`转换时的步骤，那么我们来开始解释`['1', '2', '3'].map(parseInt)`
**at first, 答案是[1, NaN, NaN]**

```js
(function (){
        var ret = ['1', '2', '3'].map((value, index)=>{
            console.log(value, index);
            return parseInt(value, index);
        });
        console.log(ret);
    })();
```

这是`['1', '2', '3'].map(parseInt)`内部执行的剖析，`value`和`index`相信大家都懂，不懂请自行[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/map),执行步骤为：
`value='1',index=0` -> `parseInt(value, index)`
`value='2',index=1` -> `parseInt(value, index)`
`value='3',index=2` -> `parseInt(value, index)`
抽离出来，其实就是

```js
parseInt('1', 0);
parseInt('2', 1);
parseInt('3', 2);
```

`parseInt('3', 2)`这是根据二进制对字符串`3`进行十进制转换对吧！！！
exm???有毛病?没毛病，老铁，就是......你家二进制有`3`?二进制不就是`0`和`1`啊

因此返回**NaN**。



### [第 3 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/5)（2019/9/21）

**题目**：什么是防抖和节流？有什么区别？如何实现？

**公司** ：挖财

**解析** ：

1、**防抖**

> 触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间

思路：

> 每次触发事件时都取消之前的延时调用方法

```js
    function debounce(fn,delay) {
        let timeout = null // 创建一个标记用来存放定时器的返回值
        return function () {
            clearTimeout(timeout) // 每当用户输入的时候把前一个 setTimeout clear 掉
            timeout = setTimeout(() => { // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
                fn.apply(this, arguments)
        }, delay)
        };
    }
    function sayHi() {
        console.log('防抖成功');
    }

    var inp = document.getElementById('inp')
    inp.addEventListener('input', debounce(sayHi,500)) // 防抖
```

提出问题：请问，为什么要 fn.apply(this, arguments);而不是这样 fn()

解答：加上 apply 确保 在 sayHi 函数里的 this 指向的是 input对象(不然就指向 window 了，不是我们想要的)。
这里的箭头函数依旧是指向 input 对象。

![mark](http://static.zxinc520.com/blog/20190921/g4jPyh09vVh7.gif)

防抖应用场景：

1. 搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。
2. 表单验证
3. 按钮提交事件。
4. 浏览器窗口缩放，resize事件等。



2、**节流**

> 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率

思路：

> 每次触发事件时都判断当前是否有等待执行的延时函数

```js
  function throttle(fn,delay) {
        let canRun = true; // 通过闭包保存一个标记
        return function () {
            if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return
            canRun = false; // 立即设置为false
            setTimeout(() => { // 将外部传入的函数的执行放在setTimeout中
                fn.apply(this, arguments);
            // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉
            canRun = true;
        }, 500);
        };
    }
    function sayHi(e) {
        console.log(e.target.innerWidth, e.target.innerHeight);
    }
    window.addEventListener('resize', throttle(sayHi,500));
```

![mark](http://static.zxinc520.com/blog/20190921/nJbaVeD1wpaz.gif)



### [第 4 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md#%E7%AC%AC-4-%E9%A2%98%E4%BB%8B%E7%BB%8D%E4%B8%8B-setmapweakset-%E5%92%8C-weakmap-%E7%9A%84%E5%8C%BA%E5%88%AB) (2019/9/22)

**题目** ：介绍下 Set、Map、WeakSet 和 WeakMap 的区别？

**解析：** [木易杨前端进阶](https://muyiy.cn/question/js/4.html) 

~~~txt
Set
    成员唯一、无序且不重复
    [value, value]，键值与键名是一致的（或者说只有键值，没有键名）
    可以遍历，方法有：add、delete、has
    
WeakSet
    成员都是对象
    成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏
    不能遍历，方法有add、delete、has
    
Map
    本质上是键值对的集合，类似集合
    可以遍历，方法很多可以跟各种数据格式转换
    
WeakMap
    只接受对象作为键名（null除外），不接受其他类型的值作为键名
    键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的
    不能遍历，方法有get、set、has、delete
 
 Set与WeakSet区别:
    1. WeakSet只能存放对象
    2. WeakSet不支持遍历, 没有size熟悉
    3. WeakSet存放的对象不会计入到对象的引用技术, 因此不会影响GC的回收
    4. WeakSet存在的对象如果在外界消失了, 那么在WeakSet里面也会不存在
    
 Map与WeakMap区别
 	1. WeakMap只能接受对象作为键名字(null除外)
	2. WeakMap键名指向对象不会计入对象的引用数
~~~



### [第 5 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/9) (2019/9/22)

**题目：** 介绍下深度优先遍历和广度优先遍历，如何实现？

解析： 我先学习一下啥是  深度优先 和 广度优先... 惭愧！！！



### [第 6 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/10) （2019/9/23）

> 弄懂了 优先遍历和广度优先遍历 再来做





### [第 7 题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/20) （2019/9/23）

**题目** ：ES5/ES6 的继承除了写法以外还有什么区别？

**解析** ： [更多](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/20)

1. `class` 声明会提升，但不会初始化赋值。`Foo` 进入暂时性死区，类似于 `let`、`const` 声明变量。
2. `class` 声明内部会启用严格模式。
3. `class` 的所有方法（包括静态方法和实例方法）都是不可枚举的。
4. `class` 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有`[[construct]]`，不能使用 `new` 来调用。
5. 必须使用 `new` 调用 `class`。
6. `class` 内部无法重写类名。







